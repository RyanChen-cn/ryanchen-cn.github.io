<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zong&#39;Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenruifeng.name/"/>
  <updated>2019-04-18T04:07:15.556Z</updated>
  <id>http://chenruifeng.name/</id>
  
  <author>
    <name>Ryan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hello</title>
    <link href="http://chenruifeng.name/2019/04/18/hello/"/>
    <id>http://chenruifeng.name/2019/04/18/hello/</id>
    <published>2019-04-18T04:07:15.000Z</published>
    <updated>2019-04-18T04:07:15.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-图的存储</title>
    <link href="http://chenruifeng.name/2018/11/13/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://chenruifeng.name/2018/11/13/考研数据结构复习-图的存储/</id>
    <published>2018-11-13T11:55:31.000Z</published>
    <updated>2018-11-27T10:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><blockquote><p>图的存储结构也分为顺序与链式，其中<br>顺序 -&gt; 邻接矩阵<br>链式 -&gt; 邻接表   针对无向图优化  -&gt; 邻接多重表  ； 针对有向图优化 -&gt; 十字链表</p></blockquote><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><blockquote><p><del>偷懒可以直接用二维数组</del><br>可以在一位数组里封装点别的东西，比如点数啥的…</p><p>注意 在初始化时 两个点没有直接路径 值为无穷大 自己到自己设为；<br>弗洛伊德算法 A记录最短路径  初始就是MGraph数组<br>            Path初始全为-1表示没有中间结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MGraph[maxSize][maxSize];</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><blockquote><p>邻接表还有一个逆邻接表 区别就是弧结构存的是指向自己的结点，<br>叫逆邻接表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArchNode</span>&#123;</span> <span class="comment">//弧结构体</span></span><br><span class="line"><span class="keyword">int</span> adjvex; <span class="comment">//从点的边指向的其他结点 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArchNode</span> *<span class="title">nextarc</span>;</span> </span><br><span class="line">&#125;ArchNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">//结点结构体</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">ArchNode *firstarc; </span><br><span class="line">&#125;VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">VNode adjlist[maxSize];</span><br><span class="line"><span class="keyword">int</span> n,e; <span class="comment">//n是结点数 e是边的个数</span></span><br><span class="line">&#125;AGraph;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/13/考研数据结构复习-图的存储/邻接表&amp;逆邻接表.png" alt="邻接表逆邻接表对比"></p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><blockquote><p>对无向图的优化  减少了存储量</p></blockquote><p><img src="/2018/11/13/考研数据结构复习-图的存储/邻接多重表-适用于无向图.png" alt="邻接多重表"></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><blockquote><p>邻接表的有向图优化  邻接表与逆邻接表的结合</p></blockquote><p><img src="/2018/11/13/考研数据结构复习-图的存储/十字链表-适用于有向图.png" alt="十字链表"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="图" scheme="http://chenruifeng.name/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-二叉树的遍历</title>
    <link href="http://chenruifeng.name/2018/10/25/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://chenruifeng.name/2018/10/25/考研数据结构复习-二叉树的遍历/</id>
    <published>2018-10-25T03:22:00.000Z</published>
    <updated>2018-10-25T03:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><blockquote><p>根左右 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">TNode *lChild, *rChild;</span><br><span class="line">&#125;TNode, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;data);</span><br><span class="line">PreOrder(T-&gt;lChild);</span><br><span class="line">PreOrder(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notRPreOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">Tree <span class="built_in">stack</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">Tree p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">stack</span>[++top] = T;</span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">-1</span>)&#123;</span><br><span class="line">p = <span class="built_in">stack</span>[top--];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rChild!=<span class="literal">NULL</span>) <span class="built_in">stack</span>[++top] = p-&gt;rChild;</span><br><span class="line"><span class="comment">//由于用栈所以先压入右边</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;lChild!=<span class="literal">NULL</span>) <span class="built_in">stack</span>[++top] = p-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><blockquote><p>这个的非递归写法比较特殊 一路向左</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">InOrder(T-&gt;lChild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;data);</span><br><span class="line">InOrder(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notRInOrder</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">Tree <span class="built_in">stack</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">Tree p = T;</span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">-1</span>||p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">stack</span>[++top]=p;</span><br><span class="line">p = p-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top!=<span class="number">-1</span>)&#123;</span><br><span class="line">p = <span class="built_in">stack</span>[top--];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;rChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><blockquote><p>后续遍历（左右根）的逆序相当于 根右左 所以可以在先序遍历（根左右）的基础上魔改加栈 改变压入顺序； </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">PostOrder(T-&gt;lChild);</span><br><span class="line">PostOrder(T-&gt;rChild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notRPostOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">Tree <span class="built_in">stack</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> stack2[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">Tree p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">stack</span>[++top] = T;</span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">-1</span>)&#123;</span><br><span class="line">p = <span class="built_in">stack</span>[top--];</span><br><span class="line">stack2[++top2]=p-&gt;data;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lChild!=<span class="literal">NULL</span>) <span class="built_in">stack</span>[++top] = p-&gt;lChild;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rChild!=<span class="literal">NULL</span>) <span class="built_in">stack</span>[++top] = p-&gt;rChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top2!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,stack2[top2--]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><blockquote><p>这是用队列的结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> size=<span class="number">3</span>;</span><br><span class="line">Tree <span class="built_in">queue</span>[size],p;</span><br><span class="line"><span class="keyword">int</span> rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> front=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>[rear++] = T;</span><br><span class="line"><span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">p = <span class="built_in">queue</span>[front];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</span><br><span class="line">front = (front+<span class="number">1</span>)%size;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lChild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">queue</span>[rear]=p-&gt;lChild;</span><br><span class="line">rear = (rear+<span class="number">1</span>)%size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rChild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">queue</span>[rear]=p-&gt;rChild;</span><br><span class="line">rear = (rear+<span class="number">1</span>)%size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="树" scheme="http://chenruifeng.name/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://chenruifeng.name/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="遍历" scheme="http://chenruifeng.name/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-二叉树</title>
    <link href="http://chenruifeng.name/2018/10/24/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://chenruifeng.name/2018/10/24/考研数据结构复习-二叉树/</id>
    <published>2018-10-24T07:55:44.000Z</published>
    <updated>2018-10-25T03:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><blockquote><p>完全二叉树可以用从0开始的数组存储，第i个结点的子结点下标分别是2*i+1，2i-1。其他二叉树勉强也能用，通过加冗余信息</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">10000</span>];</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><ol><li>指向两个孩子</li></ol><blockquote><p>孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链&gt;&gt;表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。为此，设计两种结点结构，一个是孩子链表的孩子结点  另一个是表头数组的表头节点 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">BTNode* lChild;</span><br><span class="line">BTNode* rChild;</span><br><span class="line">&#125;BTNode,*BTree;</span><br></pre></td></tr></table></figure><ol start="2"><li>孩子兄弟表示法</li></ol><blockquote><p>此方法出现在树的存储结构中，树与二叉树区别在于二叉树是分左右的，通过孩子兄弟表示法可以实现树与二叉树、森林与二叉树的互相转换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightbro</span>;</span></span><br><span class="line">&#125;CSNode;</span><br></pre></td></tr></table></figure><h2 id="二叉树与树、二叉树与森林的互相转换"><a href="#二叉树与树、二叉树与森林的互相转换" class="headerlink" title="二叉树与树、二叉树与森林的互相转换"></a>二叉树与树、二叉树与森林的互相转换</h2><blockquote><p> 由 <code>树/森林</code> 转换<code>二叉树</code>并没有改变逻辑结构 只是改变了他的存储结构，换句话说，转换并没有转换他们的逻辑结构，只是改变了存储方式。 </p></blockquote><h3 id="树-gt-二叉树"><a href="#树-gt-二叉树" class="headerlink" title="树-&gt;二叉树"></a>树-&gt;二叉树</h3><blockquote><p>双亲节点只连接树的表面上的左边的孩子，另一个指针连接兄弟</p></blockquote><p><img src="/2018/10/24/考研数据结构复习-二叉树/树-二叉树.png" alt="树-二叉树"></p><p><img src="/2018/10/24/考研数据结构复习-二叉树/二叉树.png" alt="二叉树"></p><h3 id="森林-gt-二叉树"><a href="#森林-gt-二叉树" class="headerlink" title="森林-&gt;二叉树"></a>森林-&gt;二叉树</h3><blockquote><p>森林化二叉树会多出来一步首先各自化为二叉树</p></blockquote><p><img src="/2018/10/24/考研数据结构复习-二叉树/森林.png" alt="森林"></p><p><img src="/2018/10/24/考研数据结构复习-二叉树/森林-多个二叉树.png" alt="森林-多个二叉树"></p><blockquote><p>注意到所有的二叉树的根节点都没有兄弟，所以通过兄弟结点连接起来</p></blockquote><p><img src="/2018/10/24/考研数据结构复习-二叉树/2二叉树.png" alt="二叉树"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="树" scheme="http://chenruifeng.name/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://chenruifeng.name/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-树</title>
    <link href="http://chenruifeng.name/2018/10/24/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E6%A0%91/"/>
    <id>http://chenruifeng.name/2018/10/24/考研数据结构复习-树/</id>
    <published>2018-10-24T02:54:04.000Z</published>
    <updated>2018-10-24T03:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="树的经典结论"><a href="#树的经典结论" class="headerlink" title="树的经典结论"></a>树的经典结论</h2><ol><li><p>树的结点数=所有结点度数+1</p></li><li><p>度为m的树中第I层上至多有 $$ m ^ { i-1 }  $$ 个结点</p></li><li><p>高度为h的m叉树至多有N=$$ m^{0}  $$+$$ m^{1}  $$+…….++$$ m^{n-1}  $$=(1-$$ m^{n}  $$)/(1-m)个结点</p></li><li><p>具有n个结点的m叉树的最小高度为$$ log_{m}{ [n(m-1)+1] }  $$</p></li></ol><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> pIdx;</span><br><span class="line">&#125;TNode;</span><br><span class="line">TNode tree[maxSize];</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><ol><li>孩子表示法<blockquote><p>孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链&gt;&gt;表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。为此，设计两种结点结构，一个是孩子链表的孩子结点  另一个是表头数组的表头节点 </p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>  /*孩子结点*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;CTNode,*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>    /*表头结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br></pre></td></tr></table></figure><ol start="2"><li>孩子兄弟表示法</li></ol><blockquote><p>任意一颗树，它的节点的的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该节点的第一个孩子和此节点的右兄弟：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightbro</span>;</span></span><br><span class="line">&#125;CSNode;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="树" scheme="http://chenruifeng.name/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-串</title>
    <link href="http://chenruifeng.name/2018/10/22/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E4%B8%B2/"/>
    <id>http://chenruifeng.name/2018/10/22/考研数据结构复习-串/</id>
    <published>2018-10-22T07:22:13.000Z</published>
    <updated>2018-10-23T05:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><blockquote><p>顺序存储时char[] 最后一个要放 \0 所以开6个空间不能放6个数，只能放5个 链式存储先鸽一下</p></blockquote><h3 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h3><ol><li>代码测试串的特性</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, <span class="keyword">sizeof</span>(str));<span class="comment">//输出7；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>,<span class="built_in">strlen</span>(str));<span class="comment">//输出6；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, str);<span class="comment">//输出abcdef；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, str[<span class="number">6</span>]);<span class="comment">//输出空；</span></span><br><span class="line">str[<span class="number">6</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, str[<span class="number">6</span>]);<span class="comment">//输出a；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, str);<span class="comment">//根据编译器不同结果不同 dev还能输出abcdef vs就会乱码</span></span><br><span class="line"><span class="comment">//在直接赋值是不能使用最后一个空间，但是可以单独设置最后一个存的东西  </span></span><br><span class="line"><span class="comment">//若最后一个不是 \0 可能会导致乱码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str; <span class="comment">//这个是c++里的 本质不是指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[maxSize+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Str;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    chat *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Str2; <span class="comment">//这个真香</span></span><br><span class="line"></span><br><span class="line">Str S;</span><br><span class="line">S.length = L;</span><br><span class="line">S.ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((L+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><blockquote><p>模式匹配算法默认从数组下标1开始用</p></blockquote><h3 id="简单的模式匹配算法"><a href="#简单的模式匹配算法" class="headerlink" title="简单的模式匹配算法"></a>简单的模式匹配算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;Str;</span><br><span class="line"><span class="comment">//老师更容易看得懂的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simpleMatch</span><span class="params">(Str S, Str T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>,k=i;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(S.str[i]==T.str[j])&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line">i=++k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> k;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的想法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simpleMatch</span><span class="params">(Str S, Str T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= T.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (S.str[i + j<span class="number">-1</span>] != T.str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == T.length + <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Str s, t;</span><br><span class="line">s.str = <span class="string">"/abcdef"</span>;</span><br><span class="line">s.length = <span class="number">6</span>;</span><br><span class="line">t.str = <span class="string">"/ab"</span>;</span><br><span class="line">t.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, simpleMatch(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><blockquote><p>KMP算法还是很难的啊QAQ  注意getNext 和 KMP函数 的过程非常类似 </p></blockquote><ol><li>基础版本</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;Str;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(Str T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>||T.str[j]==T.str[t])&#123;</span><br><span class="line">next[j+<span class="number">1</span>] = t+<span class="number">1</span>;</span><br><span class="line">t++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> t=next[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(Str S, Str T,<span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||S.str[i]==T.str[j])&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j=next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i-T.length;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Str s, t;</span><br><span class="line">s.str = <span class="string">"/abcdef"</span>;</span><br><span class="line">s.length = <span class="number">6</span>;</span><br><span class="line">t.str = <span class="string">"/f"</span>;</span><br><span class="line">t.length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">getNext(t,next);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, KMP(s, t,next));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>升级版</li></ol><blockquote><p>next升级成了nextval[j],整个过程类似与并查集，首先看他存在的问题若匹配第五个不成功时，next[5]=4 -&gt; next[4]=3 -&gt;next[3]=2 -&gt;next[2]=1 -&gt;next[1]=0  出现这个问题的条件是当 str[5]==str[4]时你从5跳到4没有任何意义，类似并查集的 需要递归到一个不同的地方停止才可以阻止这种浪费</p></blockquote><p><img src="/2018/10/22/考研数据结构复习-串/next.png" alt="next"></p><p><img src="/2018/10/22/考研数据结构复习-串/nextval.png" alt="nextval"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNextval</span><span class="params">(Str T,<span class="keyword">int</span> nextval[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>||T.str[j]==T.str[t])&#123;</span><br><span class="line"><span class="keyword">if</span>(T.str[j+<span class="number">1</span>]!=T.str[t+<span class="number">1</span>])</span><br><span class="line">nextval[j+<span class="number">1</span>] = t+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">nextval[j+<span class="number">1</span>] = nextval[t+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">t++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> t=nextval[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(Str T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>||T.str[j]==T.str[t])&#123;</span><br><span class="line">next[j+<span class="number">1</span>] = t+<span class="number">1</span>;</span><br><span class="line">t++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> t=next[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="串" scheme="http://chenruifeng.name/tags/%E4%B8%B2/"/>
    
      <category term="KMP" scheme="http://chenruifeng.name/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-队列</title>
    <link href="http://chenruifeng.name/2018/10/19/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E9%98%9F%E5%88%97/"/>
    <id>http://chenruifeng.name/2018/10/19/考研数据结构复习-队列/</id>
    <published>2018-10-19T08:38:31.000Z</published>
    <updated>2018-10-19T11:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>队列是一种受限的线性表 它只支持FIFO （<em>当然还有一些所谓的双端队列不遵守这个规则</em>）</p></blockquote><p><img src="/2018/10/19/考研数据结构复习-队列/queue.png" alt="queue"></p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><blockquote><p>顺序队列是利用率较低的结构，它不像栈那样一头出，它像一个游标一样只能向右滑动。所以划着划着就到头了。</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[MaxSize];<span class="comment">//</span></span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">  <span class="comment">//front指向队头元素 rear指向队尾元素后面一个位置 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue &amp;q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.rear==q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(SqQueue &amp;q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.rear==MaxSize) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isFull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.data[q.rear] =x;</span><br><span class="line">q.rear++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;q,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = q.data[q.front];</span><br><span class="line">q.front++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><blockquote><p>循环队列是对顺序队列的优化，让顺序的数组通过取余运算连乘环，但由于队空条件是q.front==q.rear，当对满时尾追上头就也会 q.front==q.rear 所以出现两类方案解决</p><ol><li>放弃一个空间 队满判定改为 (q.rear+1)%==q.rear</li><li>增加结构体携带信息量 记录<code>count</code>或者<code>上一步操作类型</code></li></ol></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[MaxSize];<span class="comment">//</span></span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">  <span class="comment">//front指向队头元素 rear指向队尾元素后面一个位置 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue &amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.rear == q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(SqQueue &amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((q.rear+<span class="number">1</span>)%MaxSize == q.front ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;q, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q.data[q.rear] = x;</span><br><span class="line">q.rear=(q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;q, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = q.data[q.front];</span><br><span class="line">q.front=(q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><blockquote><p> 在单链表的基础上搞了一个栈顶结构体 即指向链的指针+count</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        LinkNode *front,*rear;<span class="comment">//链表头 链表尾</span></span><br><span class="line">&#125;LinkQueue;<span class="comment">//先进先出</span></span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//头和尾指向同一个结点</span></span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        s-&gt;data=x;s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        Q.rear-&gt;next=s;</span><br><span class="line">        Q.rear=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队  头部删除法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列为空</span></span><br><span class="line">        LinkNode *p=Q.front-&gt;next;<span class="comment">//头结点什么都没存，所以头结点的下一个节点才有数据</span></span><br><span class="line">        x=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;<span class="comment">//断链</span></span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)<span class="comment">//删除的是最后一个元素</span></span><br><span class="line">                Q.rear=Q.front;<span class="comment">//队列置为空</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="队列" scheme="http://chenruifeng.name/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-栈合集</title>
    <link href="http://chenruifeng.name/2018/10/19/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E6%A0%88%E5%90%88%E9%9B%86/"/>
    <id>http://chenruifeng.name/2018/10/19/考研数据结构复习-栈合集/</id>
    <published>2018-10-19T07:59:17.000Z</published>
    <updated>2018-10-19T08:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>栈是一种受限的线性表 它只支持LIFO</p></blockquote><p><img src="/2018/10/19/考研数据结构复习-栈合集/stack_representation.jpg" alt="stack"></p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><blockquote><p>顺序栈是相对常用的栈 很简单使用 栈顶指针指向栈顶元素</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackOverflow</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackOverflow(S)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">S.data[S.top + <span class="number">1</span>] = x;</span><br><span class="line">S.top++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(S)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = S.data[S.top];</span><br><span class="line">S.top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><blockquote><p>共享栈是顺序栈的魔改版  感觉非常愚蠢的结构 </p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top1;</span><br><span class="line"><span class="keyword">int</span> top2; </span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackOverflow</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top1 +<span class="number">1</span> == S.top2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> x,<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackOverflow(S)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stackNum==<span class="number">1</span>) &#123;</span><br><span class="line">S.data[S.top1+<span class="number">1</span>];</span><br><span class="line">S.top1++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(stackNum==<span class="number">2</span>) &#123;</span><br><span class="line">S.data[S.top2<span class="number">-1</span>];</span><br><span class="line">S.top2--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><blockquote><p> 在单链表的基础上搞了一个栈顶结构体 即指向链的指针+count</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkLNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">LinkLNode top;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>2.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack *&amp;L, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">LinkLNode p = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data = x;</span><br><span class="line">p-&gt;next = L-&gt;top;</span><br><span class="line">L-&gt;top = p;</span><br><span class="line">L-&gt;count++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack *&amp;L, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">LinkLNode p;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p = L-&gt;top;</span><br><span class="line">L-&gt;top = p-&gt;next;</span><br><span class="line">x = p-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">L-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="栈" scheme="http://chenruifeng.name/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-循环链表&amp;静态链表</title>
    <link href="http://chenruifeng.name/2018/10/15/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://chenruifeng.name/2018/10/15/考研数据结构复习-循环链表/</id>
    <published>2018-10-15T08:42:31.000Z</published>
    <updated>2018-10-16T02:14:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>线性表从存储结构上来分，主要是顺序表和各种链表，值得注意的是顺序存储不等于顺序存取，数组就是一种<strong>随机</strong>存取的顺序存储结构</p></blockquote><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><p>循环链表  普通链表的头尾相连  </p><p><del>为了偷懒直接用的单链表改的</del></p><p>头结点应该要存数的，有时间改吧</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkLNode;</span><br></pre></td></tr></table></figure><p>2.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LNode * head=(LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">head=tailInsertCreat(head);</span><br><span class="line">showNode(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,isEmpty(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkLNode <span class="title">tailInsertCreat</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line">LNode *s, *l;</span><br><span class="line">L = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">l = L;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">l-&gt;data = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">999</span>) <span class="keyword">break</span>;</span><br><span class="line">s = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">l-&gt;next = s;</span><br><span class="line">l = s;</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;next = L; <span class="comment">//只有这句变了 </span></span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next == L) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//循环双链表时 L-&gt;prior==L 也可以判断是否为空 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showNode</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;data);</span><br><span class="line">LinkLNode p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != L) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><h4 id="静态链表-1"><a href="#静态链表-1" class="headerlink" title="静态链表"></a>静态链表</h4><blockquote><p>结构体定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;SLinklist[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>链表完</p><p><img src="/2018/10/15/考研数据结构复习-循环链表/后背.jpg" alt="完工"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="链表" scheme="http://chenruifeng.name/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-双链表</title>
    <link href="http://chenruifeng.name/2018/10/15/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <id>http://chenruifeng.name/2018/10/15/考研数据结构复习-双链表/</id>
    <published>2018-10-15T08:03:17.000Z</published>
    <updated>2018-10-15T08:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>线性表从存储结构上来分，主要是顺序表和各种链表，值得注意的是顺序存储不等于顺序存取，数组就是一种<strong>随机</strong>存取的顺序存储结构</p></blockquote><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><blockquote><p>双链表 data 指向自己的指针*2</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure><p>2.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">DLinklist head=(DLinklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">head = tailInsertCreat(head);</span><br><span class="line">showDNode(head); </span><br><span class="line">delElem(head,<span class="number">1</span>);</span><br><span class="line">showDNode(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinklist <span class="title">tailInsertCreat</span><span class="params">(DLinklist &amp;L)</span> </span>&#123;</span><br><span class="line">DNode *s, *l;</span><br><span class="line">L = (DLinklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">l = L;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">s = (DLinklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">l-&gt;next = s;</span><br><span class="line">s-&gt;prior = l;</span><br><span class="line">l = s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DLinklist <span class="title">getElem</span><span class="params">(DLinklist L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">DLinklist p = L;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//if(i==0) return L;</span></span><br><span class="line"><span class="keyword">while</span> (p&amp;&amp;j&lt;i) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delElem</span><span class="params">(DLinklist L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">DLinklist s,p = getElem(L,i<span class="number">-1</span>);</span><br><span class="line">s = p-&gt;next;</span><br><span class="line">p-&gt;next = s-&gt;next;</span><br><span class="line">s-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="链表" scheme="http://chenruifeng.name/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习-单链表</title>
    <link href="http://chenruifeng.name/2018/10/15/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://chenruifeng.name/2018/10/15/考研数据结构复习-单链表/</id>
    <published>2018-10-15T05:35:54.000Z</published>
    <updated>2018-10-15T08:11:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>线性表从存储结构上来分，主要是顺序表和各种链表，值得注意的是顺序存储不等于顺序存取，数组就是一种<strong>随机</strong>存取的顺序存储结构</p></blockquote><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><p>单链表 data+ 指向自己的类型的指针</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkLNode;</span><br></pre></td></tr></table></figure><p>2.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LNode *head = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//headInsertCreat(head);</span></span><br><span class="line">tailInsertCreat(head);</span><br><span class="line">showLNode(head);</span><br><span class="line"><span class="comment">//int del;</span></span><br><span class="line"><span class="keyword">int</span> pos,val;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pos,&amp;val);</span><br><span class="line">addElem(head,pos,val);</span><br><span class="line"><span class="comment">//scanf("%d",&amp;del);</span></span><br><span class="line"><span class="comment">//delElem(head,del);</span></span><br><span class="line">showLNode(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,getLongth(head));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkLNode <span class="title">getElem</span><span class="params">(LinkLNode L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">LinkLNode p = L;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//if(i==0) return L;</span></span><br><span class="line"><span class="keyword">while</span> (p&amp;&amp;j&lt;i) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delElem</span><span class="params">(LinkLNode L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">LinkLNode s,p = getElem(L,i<span class="number">-1</span>);</span><br><span class="line">s = p-&gt;next;</span><br><span class="line">p-&gt;next = s-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElem</span><span class="params">(LinkLNode L,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">LinkLNode temp,s,p = getElem(L,i<span class="number">-1</span>);</span><br><span class="line">s = p-&gt;next;</span><br><span class="line">temp = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">temp-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInsertCreat</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line">LNode *s;<span class="comment">//临时指针； </span></span><br><span class="line"><span class="keyword">int</span> num, temp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">L = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">s = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">s-&gt;data = temp;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInsertCreat</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line">LNode *s, *l;</span><br><span class="line">L = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">l = L;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">999</span>) &#123;</span><br><span class="line">s = (LinkLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">l-&gt;next = s;</span><br><span class="line">l = s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showLNode</span><span class="params">(LinkLNode &amp;L)</span> </span>&#123;</span><br><span class="line">LinkLNode p = L;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongth</span><span class="params">(LinkLNode &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">LinkLNode p=L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="链表" scheme="http://chenruifeng.name/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>考研数据结构复习---顺序表</title>
    <link href="http://chenruifeng.name/2018/07/26/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>http://chenruifeng.name/2018/07/26/考研数据结构复习-顺序表/</id>
    <published>2018-07-26T13:30:40.000Z</published>
    <updated>2018-07-26T13:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><blockquote><p>线性表从存储结构上来分，主要是顺序表和各种链表，值得注意的是顺序存储不等于顺序存取，数组就是一种<strong>随机</strong>存取的顺序存储结构</p></blockquote><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><blockquote><p>顺序表在我以前的认知里就是数组，但是王道天勤上貌似用结构更多一些。</p></blockquote><ol><li>结构体定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//动态定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;DSqList;</span><br></pre></td></tr></table></figure><p>2.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqList sl;</span><br><span class="line">sl.length = <span class="number">0</span>;</span><br><span class="line">DSqList dsl;</span><br><span class="line">dsl.data = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];<span class="comment">//c++写法</span></span><br><span class="line">dsl.data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*MaxSize);<span class="comment">//c写法</span></span><br></pre></td></tr></table></figure><p>3.简单操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElem</span><span class="params">(SqList &amp;sl, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">sl.data[sl.length] = elem;</span><br><span class="line">sl.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPos</span><span class="params">(SqList sl, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;sl.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sl.data[i] &gt;= elem) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sl.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElem</span><span class="params">(SqList &amp;sl, <span class="keyword">int</span> pos, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos &gt;= MaxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sl.length - <span class="number">1</span>; i &gt;= pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">sl.data[i + <span class="number">1</span>] = sl.data[i];</span><br><span class="line">&#125;</span><br><span class="line">sl.data[pos] = elem;</span><br><span class="line">sl.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showElem</span><span class="params">(SqList sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sl.length; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl.data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构复习" scheme="http://chenruifeng.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="http://chenruifeng.name/2018/04/15/hello-blog/"/>
    <id>http://chenruifeng.name/2018/04/15/hello-blog/</id>
    <published>2018-04-15T02:25:47.000Z</published>
    <updated>2019-04-18T04:06:47.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hello，world"><a href="#Hello，world" class="headerlink" title="Hello，world."></a>Hello，world.</h1><h2 id="学习Markdown"><a href="#学习Markdown" class="headerlink" title="学习Markdown"></a>学习Markdown</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>*</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>1<h3 id="待办事宜"><a href="#待办事宜" class="headerlink" title="待办事宜"></a>待办事宜</h3></li></ol><ul><li style="list-style: none"><input type="checkbox"> 高数微分方程学习</li><li style="list-style: none"><input type="checkbox"> 蓝桥杯国赛准备</li><li style="list-style: none"><input type="checkbox"> 英语六级</li><li style="list-style: none"><input type="checkbox"> 英语口语</li><li style="list-style: none"><input type="checkbox" checked> 建一个博客</li></ul><blockquote><p>这是一条引用</p></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p> <a href="http://bilibili.com" target="_blank" rel="noopener">bilibili</a></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><strong>粗体</strong></p><p><em>斜体</em></p><p><strong><em>粗斜</em></strong></p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://chenruifeng.name/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="划水" scheme="http://chenruifeng.name/tags/%E5%88%92%E6%B0%B4/"/>
    
  </entry>
  
</feed>
